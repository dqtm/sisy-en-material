digitalSmooth
=================================================================
digitalSmooth(data, arrayName)

/* digitalSmooth
 Paul Badger 2007
 A digital smoothing filter for smoothing sensor jitter 
 This filter accepts one new piece of data each time through a loop, which the 
 filter inputs into a rolling array, replacing the oldest data with the latest reading.
 The array is then transferred to another array, and that array is sorted from low to high. 
 Then the highest and lowest %15 of samples are thrown out. The remaining data is averaged
 and the result is returned.

 Every sensor used with the digitalSmooth function needs to have its own array to hold 
 the raw sensor values. This array is then passed to the function, for it's use.
 This is done with the name of the array associated with the particular sensor.
 */

#define SensorPin1      0
#define SensorPin2      0
#define filterSamples   13              // filterSamples should  be an odd number, no smaller than 3
int sensSmoothArray1 [filterSamples];   // array for holding raw sensor values for sensor1 
int sensSmoothArray2 [filterSamples];   // array for holding raw sensor values for sensor2 

int rawData1, smoothData1;  // variables for sensor1 data
int rawData2, smoothData2;  // variables for sensor2 data

void setup(){
  Serial.begin(9600);
}
void loop(){       // test the digitalSmooth function
  rawData1 = analogRead(SensorPin1);                        // read sensor 1
  smoothData1 = digitalSmooth(rawData1, sensSmoothArray1);  // every sensor you use with digitalSmooth needs its own array

    Serial.print(rawData1);
    Serial.print("   ");
    Serial.println(smoothData1);

  rawData2 = analogRead(SensorPin2);                        // read sensor 2
  smoothData2 = digitalSmooth(rawData2, sensSmoothArray2);  // every sensor you use with digitalSmooth needs its own array

}

int digitalSmooth(int rawIn, int *sensSmoothArray){     // "int *sensSmoothArray" passes an array to the function - the asterisk indicates the array name is a pointer
  int j, k, temp, top, bottom;
  long total;
  static int i;
 // static int raw[filterSamples];
  static int sorted[filterSamples];
  boolean done;

  i = (i + 1) % filterSamples;    // increment counter and roll over if necc. -  % (modulo operator) rolls over variable
  sensSmoothArray[i] = rawIn;                 // input new data into the oldest slot

  // Serial.print("raw = ");

  for (j=0; j<filterSamples; j++){     // transfer data array into anther array for sorting and averaging
    sorted[j] = sensSmoothArray[j];
  }

  done = 0;                // flag to know when we're done sorting              
  while(done != 1){        // simple swap sort, sorts numbers from lowest to highest
    done = 1;
    for (j = 0; j < (filterSamples - 1); j++){
      if (sorted[j] > sorted[j + 1]){     // numbers are out of order - swap
        temp = sorted[j + 1];
        sorted [j+1] =  sorted[j] ;
        sorted [j] = temp;
        done = 0;
      }
    }
  }

/*
  for (j = 0; j < (filterSamples); j++){    // print the array to debug
    Serial.print(sorted[j]); 
    Serial.print("   "); 
  }
  Serial.println();
*/

  // throw out top and bottom 15% of samples - limit to throw out at least one from top and bottom
  bottom = max(((filterSamples * 15)  / 100), 1); 
  top = min((((filterSamples * 85) / 100) + 1  ), (filterSamples - 1));   // the + 1 is to make up for asymmetry caused by integer rounding
  k = 0;
  total = 0;
  for ( j = bottom; j< top; j++){
    total += sorted[j];  // total remaining indices
    k++; 
    // Serial.print(sorted[j]); 
    // Serial.print("   "); 
  }

//  Serial.println();
//  Serial.print("average = ");
//  Serial.println(total/k);
  return total / k;    // divide by number of samples
}

==================================================================================0

FIR- example
http://arduino.cc/forum/index.php/topic,44412.0.html



/*

Simple FIR filter implementation

This routine is just written as an excersize in Arduino programming.
The routine implements a Finite Impuls Response filter.

Finite Impuls Response filters can be used to create all kinds of filters.
Filters can be used to partially remove noise, remove 'DC' offsets, or 'shape' analogue values. See http://en.wikipedia.org/wiki/Finite_impulse_response to read more aboute FIR filters. Several online sources are available to generate the coefficients. Google for the various sources.

About the routine: it is not really optimized for anything. It accepts exactly one float, spits out one float, and should be called for every sample. For the filter to work as expected, the samples should be 'equidistant' in time, so taken at identical intervals.

Making this an 'integer' function (to make it more usable with the onboard analog inputs) can be done. This would also limit execution time and memory usage.

Talking performance: using floats a 5 tap cycle takes about 180µs, so that is pretty fast and allows about 3~4kHz sample rate, taking some overhead in the main loop into consideration. Using ints or even better bytes should fraction the looptime by at least 4 to 8 times!

Rene Knuvers, 14JUL2010, arduino@reneknuvers.nl

*/

#define FILTERTAPS 5            // The number of taps in your filter, or better the number of coefficients

// declare array for values
float values[FILTERTAPS] = {0, 0, 0, 0, 0}; // to have a nice start up, fill the array with 0's
// NOTE: this could be 1 shorter, as we already have the input in a variable. This would save stack size/memory

// declare input and output variables
float input = 1; // without a real input, looking at the step respons (input at unity, 1) would be nice to see
float output = 0; // output as a 0, but that doesn't really matter

// our counter, real life applications won't need this
byte n = 0;

void setup() {
      Serial.begin(115200);      // open the serial port, I like them fast ;-)
}

float fir(float in){
      static byte k;                  // k stores a pointer to create a circular memory through the array. This variable remains its value the next time we call the fir routine (hence 'static')
      byte i = 0;                        // i is a counter to step through the filter coefficients and stored values
      float out = 0;                        // out is the return variable. It is set to 0 every time we call the filter!

      values[k] = input;                  // store the input in the array at the current pointer position

       
      // declare variables for coefficients
        // these should be calculated by hand, or using a tool
      // in case a phase linear filter is required, the coefficients are symmetric
      // for time optimization it seems best to enter symmetric values like below
      float coef[FILTERTAPS] = { 0.021, 0.096, 0.146, 0.096, 0.021};

      //declare gain coefficient to scale the output back to normal
      float gain = 0.38; // set to 1 and input unity to see what this needs to be

      
      for (i=0; i<FILTERTAPS; i++) {            // we step through the array
            out += coef[i] * values[(i + k) % FILTERTAPS];      // ... and add and multiply each value to accumulate the output
                                    //  (i + k) % FILTERTAPS creates a cyclic way of getting through the array
        }
      out /= gain;                        // We need to scale the output (unless the coefficients provide unity gain in the passband)

      k = (k+1) % FILTERTAPS;                  // k is increased and wraps around the FILTERTAPS, so next time we will overwrite the oldest saved sample in the array
      
        return out;                        // we send the output value back to whoever called the routine

}


void loop() {

      // This is the loop that takes care of calling the FIR filter for some samples

      for (n = 0; n < FILTERTAPS + 2; n++) {             // If you like to see the step response, take at least as many cycles as the length of your FIR filter (FILTERTAPS + 1 or 2)
            Serial.print("n= ");            // print the sample number
            Serial.println(n, DEC);
            Serial.println("Now calling fir...");
            output = fir(input);            // here we call the fir routine with the input. The value 'fir' spits out is stored in the output variable.
            Serial.print("fir presented the following value= ");
            Serial.println(output);            // just for debugging or to understand what it does, print the output value
      }
      while (true) {};                  // endless loop
}
==========================================================================================
